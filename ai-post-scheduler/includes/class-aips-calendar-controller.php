<?php
if (!defined('ABSPATH')) {
    exit;
}

class AIPS_Calendar_Controller {

    private $schedule_table;
    private $templates_table;

    public function __construct() {
        global $wpdb;
        $this->schedule_table = $wpdb->prefix . 'aips_schedule';
        $this->templates_table = $wpdb->prefix . 'aips_templates';

        add_action('wp_ajax_aips_get_calendar_events', array($this, 'ajax_get_calendar_events'));
    }

    public function ajax_get_calendar_events() {
        check_ajax_referer('aips_ajax_nonce', 'nonce');

        $start = isset($_GET['start']) ? sanitize_text_field($_GET['start']) : date('Y-m-01');
        $end = isset($_GET['end']) ? sanitize_text_field($_GET['end']) : date('Y-m-t');

        $events = array();

        // 1. Fetch Published/Pending Posts (Historical)
        // We look for posts generated by AIPS?
        // We can check post_meta '_aips_generated' or similar if we tag them.
        // Assuming we rely on AIPS History or just generic posts?
        // The user wants a "Content Calendar", likely all posts or just AIPS posts.
        // Let's rely on AIPS History for accuracy of "generated" content,
        // OR query WP_Query with specific category if set?
        // Let's use AIPS History joined with Posts table to get actual status.

        global $wpdb;
        $history_table = $wpdb->prefix . 'aips_history';

        // Fetch from history (Completed items)
        $posts_query = $wpdb->get_results($wpdb->prepare("
            SELECT h.post_id, h.generated_title, h.status, p.post_date, p.post_status
            FROM {$history_table} h
            LEFT JOIN {$wpdb->posts} p ON h.post_id = p.ID
            WHERE p.post_date BETWEEN %s AND %s
            AND p.post_status IN ('publish', 'future', 'draft', 'pending')
        ", $start . ' 00:00:00', $end . ' 23:59:59'));

        foreach ($posts_query as $post) {
            $color = '#2271b1'; // Default Blue
            if ($post->post_status === 'publish') $color = '#00a32a'; // Green
            if ($post->post_status === 'pending') $color = '#dba617'; // Yellow
            if ($post->post_status === 'draft') $color = '#999'; // Gray

            $events[] = array(
                'id' => 'post-' . $post->post_id,
                'title' => $post->generated_title ?: 'Untitled Post',
                'start' => $post->post_date,
                'status' => $post->post_status,
                'type' => 'post',
                'color' => $color,
                'url' => get_edit_post_link($post->post_id, 'raw')
            );
        }

        // 2. Projected Future Schedules
        // We need to project recurring schedules onto the calendar range.
        $schedules = $wpdb->get_results("
            SELECT s.*, t.name as template_name
            FROM {$this->schedule_table} s
            JOIN {$this->templates_table} t ON s.template_id = t.id
            WHERE s.is_active = 1
        ");

        $interval_calc = new AIPS_Interval_Calculator();
        $start_ts = strtotime($start);
        $end_ts = strtotime($end);

        foreach ($schedules as $schedule) {
            $current_run_ts = strtotime($schedule->next_run);

            // Loop while next run is before end date
            // We use a safety limit to prevent infinite loops on small intervals
            $limit = 100;

            // Advance until we are inside or past the window
            while ($current_run_ts <= $end_ts && $limit > 0) {

                if ($current_run_ts >= $start_ts) {
                    $events[] = array(
                        'id' => 'schedule-' . $schedule->id . '-' . $current_run_ts,
                        'title' => 'Scheduled: ' . $schedule->template_name,
                        'start' => date('Y-m-d H:i:s', $current_run_ts),
                        'status' => 'scheduled',
                        'type' => 'schedule',
                        'color' => '#dcdcde', // Light Gray
                        'textColor' => '#000',
                        'schedule_id' => $schedule->id
                    );
                }

                // Store the previous timestamp to detect stalled calculations
                $previous_run_ts = $current_run_ts;

                // Calculate next
                $rules = !empty($schedule->advanced_rules) ? json_decode($schedule->advanced_rules, true) : null;
                $next_date_str = $interval_calc->calculate_next_run($schedule->frequency, date('Y-m-d H:i:s', $current_run_ts), $rules);
                $current_run_ts = strtotime($next_date_str);

                // If interval calculation failed or returned same/earlier time, break
                if ($current_run_ts <= $previous_run_ts) break;
                $limit--;
            }
        }

        wp_send_json_success(array('events' => $events));
    }
}
