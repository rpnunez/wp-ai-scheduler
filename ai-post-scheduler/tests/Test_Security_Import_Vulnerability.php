<?php
/**
 * Security tests for Import functionality
 *
 * @package AI_Post_Scheduler
 */

class Test_Security_Import_Vulnerability extends WP_UnitTestCase {

    private $import_handler;
    private $original_wpdb;

    public function setUp(): void {
        parent::setUp();

        // Manually load required classes if not already loaded
        if (!class_exists('AIPS_Data_Management_Import')) {
            require_once dirname(dirname(__FILE__)) . '/includes/class-aips-data-management-import.php';
        }
        if (!class_exists('AIPS_Data_Management_Import_MySQL')) {
            require_once dirname(dirname(__FILE__)) . '/includes/class-aips-data-management-import-mysql.php';
        }
        if (!class_exists('AIPS_DB_Manager')) {
            require_once dirname(dirname(__FILE__)) . '/includes/class-aips-db-manager.php';
        }

        // Mock AIPS_DB_Manager::get_full_table_names if needed,
        // but it's a static method that likely relies on $wpdb->prefix.
        // The mock $wpdb in bootstrap has a prefix 'wp_'.

        $this->import_handler = new AIPS_Data_Management_Import_MySQL();

        // Save global wpdb
        global $wpdb;
        $this->original_wpdb = $wpdb;

        // Create a spy for wpdb
        $wpdb = $this->create_wpdb_spy();
    }

    public function tearDown(): void {
        global $wpdb;
        $wpdb = $this->original_wpdb;
        parent::tearDown();
    }

    private function create_wpdb_spy() {
        return new class {
            public $prefix = 'wp_';
            public $executed_queries = array();
            public $last_error = '';

            public function prepare($query, ...$args) {
                if (empty($args)) {
                    return $query;
                }
                foreach ($args as $arg) {
                    $query = preg_replace('/%[sd]/', is_numeric($arg) ? $arg : "'$arg'", $query, 1);
                }
                return $query;
            }

            public function query($query) {
                $this->executed_queries[] = trim($query);
                return true;
            }

            // Mock other methods needed
            public function get_results($query) { return []; }
            public function get_var($query) { return null; }
            public function get_row($query) { return null; }
        };
    }

    /**
     * Test that a malicious DELETE query targeting a non-plugin table is BLOCKED.
     *
     * Current vulnerability allows this if we mention a plugin table in a comment or string (if splitting is bad)
     * OR if we just mention a plugin table in the query string somewhere.
     */
    public function test_malicious_delete_execution() {
        // Create a malicious SQL file content
        // This query tries to delete from wp_users.
        // We add a WHERE clause that is always false for the delete but references the plugin table to bypass validation.
        // OR simpler: "DELETE FROM wp_users WHERE ID=1; -- wp_ai_post_scheduler_history"

        // Note: The current split_sql_file removes comments first.
        // So "DELETE FROM wp_users WHERE ID=1; -- wp_ai_post_scheduler_history"
        // becomes "DELETE FROM wp_users WHERE ID=1"
        // The validation check fails because it doesn't find the plugin table name.

        // However, if we do:
        // "DELETE FROM wp_users WHERE user_login = 'admin' AND 'wp_ai_post_scheduler_history' = 'wp_ai_post_scheduler_history';"
        // valid_table check passes (stripos finds the string).
        // It does NOT contain TABLE or INSERT.
        // So it executes!

        $malicious_sql = "DELETE FROM wp_users WHERE user_login = 'admin' AND 'wp_ai_post_scheduler_history' = 'wp_ai_post_scheduler_history';";

        // Wrap it in the header that is expected
        $file_content = "-- AI Post Scheduler Data Export\n" . $malicious_sql;

        $file_path = sys_get_temp_dir() . '/malicious_import.sql';
        file_put_contents($file_path, $file_content);

        // Run import
        $result = $this->import_handler->import($file_path);

        global $wpdb;
        $executed = false;
        foreach ($wpdb->executed_queries as $q) {
            if (strpos($q, 'DELETE FROM wp_users') !== false) {
                $executed = true;
                break;
            }
        }

        // Clean up
        unlink($file_path);

        // Assert that the query was NOT executed
        $this->assertFalse($executed, 'Security Fix Verified: Malicious DELETE query was blocked.');
        $this->assertTrue(is_wp_error($result), 'Security Fix Verified: Import returned WP_Error for invalid query.');
    }

    /**
     * Test SQL splitting vulnerability
     */
    public function test_sql_splitting_vulnerability() {
        // Malicious SQL that uses a semicolon in a string to break logic
        // INSERT INTO wp_ai_post_scheduler_history (title) VALUES ('Hello; DROP TABLE wp_users; --');

        // The fix now strictly validates queries, so DELETE should be blocked even if splitting works.
        // We also improved splitting, but the validation is the primary defense here against the DELETE.

        $sql = "INSERT INTO wp_aips_history (generated_title) VALUES ('Safe'); DELETE FROM wp_users WHERE user_login = 'admin' AND 'wp_aips_history'='wp_aips_history';";
         $file_content = "-- AI Post Scheduler Data Export\n" . $sql;

        $file_path = sys_get_temp_dir() . '/splitting_import.sql';
        file_put_contents($file_path, $file_content);

        $result = $this->import_handler->import($file_path);

        global $wpdb;
        $deleted = false;
        foreach ($wpdb->executed_queries as $q) {
            if (strpos($q, 'DELETE FROM wp_users') !== false) {
                $deleted = true;
                break;
            }
        }

        unlink($file_path);

        $this->assertFalse($deleted, 'Security Fix Verified: Chained DELETE query was blocked.');
        $this->assertTrue(is_wp_error($result), 'Security Fix Verified: Import returned WP_Error for chained invalid query.');
    }
}
